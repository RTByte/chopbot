{
  "_args": [
    [
      {
        "raw": "node-i18n@github:eslachance/node-i18n",
        "scope": null,
        "escapedName": "node-i18n",
        "name": "node-i18n",
        "rawSpec": "github:eslachance/node-i18n",
        "spec": "github:eslachance/node-i18n",
        "type": "hosted",
        "hosted": {
          "type": "github",
          "ssh": "git@github.com:eslachance/node-i18n.git",
          "sshUrl": "git+ssh://git@github.com/eslachance/node-i18n.git",
          "httpsUrl": "git+https://github.com/eslachance/node-i18n.git",
          "gitUrl": "git://github.com/eslachance/node-i18n.git",
          "shortcut": "github:eslachance/node-i18n",
          "directUrl": "https://raw.githubusercontent.com/eslachance/node-i18n/master/package.json"
        }
      },
      "/home/michael/~/ChopBot/node_modules/komada"
    ]
  ],
  "_from": "eslachance/node-i18n",
  "_id": "node-i18n@0.0.1",
  "_inCache": true,
  "_location": "/node-i18n",
  "_phantomChildren": {},
  "_requested": {
    "raw": "node-i18n@github:eslachance/node-i18n",
    "scope": null,
    "escapedName": "node-i18n",
    "name": "node-i18n",
    "rawSpec": "github:eslachance/node-i18n",
    "spec": "github:eslachance/node-i18n",
    "type": "hosted",
    "hosted": {
      "type": "github",
      "ssh": "git@github.com:eslachance/node-i18n.git",
      "sshUrl": "git+ssh://git@github.com/eslachance/node-i18n.git",
      "httpsUrl": "git+https://github.com/eslachance/node-i18n.git",
      "gitUrl": "git://github.com/eslachance/node-i18n.git",
      "shortcut": "github:eslachance/node-i18n",
      "directUrl": "https://raw.githubusercontent.com/eslachance/node-i18n/master/package.json"
    }
  },
  "_requiredBy": [
    "/komada"
  ],
  "_resolved": "git://github.com/eslachance/node-i18n.git#e84331497ee7e62afabaa70a127a5c75c9c427ca",
  "_shasum": "4953aad295b42ed2bc3d141f9d78b64956249521",
  "_shrinkwrap": null,
  "_spec": "node-i18n@github:eslachance/node-i18n",
  "_where": "/home/michael/~/ChopBot/node_modules/komada",
  "author": {
    "name": "Évelyne Lachance"
  },
  "bugs": {
    "url": "https://github.com/eslachance/node-i18n/issues"
  },
  "dependencies": {},
  "description": "Internationalization module using ES6 Template Literals and JSON localization files.",
  "devDependencies": {},
  "gitHead": "e84331497ee7e62afabaa70a127a5c75c9c427ca",
  "homepage": "https://github.com/eslachance/node-i18n#readme",
  "keywords": [
    "i18n",
    "localization",
    "internationalization",
    "translation"
  ],
  "license": "MIT",
  "main": "app.js",
  "name": "node-i18n",
  "optionalDependencies": {},
  "readme": "# node-i18n\n`node-i18n` makes the attempt of being a very *clean* and *simple* internationalization/localization module. It does not, however, do anything remotely \"advanced\" such as proper capitalization, conjugation or pluralization. If you require this, please check out [i18next](http://i18next.com/). I find it too complex and ugly to use, but it *is* absolutely more complete!\n\nTo make the use of the module as simple as possible, we take advantage of the functionalities present in ES6 Tagged Template Literals. This is because you can easily apply a function (tag) to template literals by calling it before: \n\n```js\nconst capitalize = (string) => {\n\treturn string.toUpperCase();\n}\n\nconsole.log(capitalize `This is an example string.`);\n// output: THIS IS AN EXAMPLE STRING\n```\n\n> Note that you need `node.js` version `6.x` or higher to use this module. It *will not* work in `node 0.12`. It was about time to updated anyway, right?\n\n##Setup\n\nThe configuration will need to contain the translation strings for each language, in the following format: \n\n```js\nlet bundles = {\n  \"fr\": {\n    currency: \"CAD\",\n    locale: \"fr-FR\",\n    strings: {\n      \"This is a string\": \"Ceci est une chaîne\"\n    }\n  },\n  \"de\": {\n    currency: \"EUR\",\n    locale: \"de-DE\",\n    strings: {\n      \"This is a string\": \"Dies ist ein String\"\n    }\n  },\n  \"zh\": {\n    currency: \"CNY\",\n    locale: \"zh-Hant-CN\",\n    strings: {\n      \"This is a string\": \"这是一个字符串\"\n    }\n  }\n};\n```\n\nThis bundle can be captured from a JSON file or build from multiple sources. For instance in my test, I load each language from its own file: \n\n```js\nfor(const lang in bundles) {\n  let bundleContents = JSON.parse(fs.readFileSync(`./locs/${bundles[lang].locale}.json`, 'utf8'));\n  bundles[lang].strings = bundleContents;\n}\n```\n\n\n### Usage\n\nUsing node-i18n is a simple question of initializing the module, setting up a language, and using it on a string.\n\n```js\nconst I18n = require(\"node-i18n\");\nconst fs = require(\"fs\");\n\nconst bundles = require(\"./bundles.js\");\n\nI18n.init({bundles: bundles, defaultCurrency: 'USD'});\n\n// Example string usage, including variable and currency.\nlet name = 'Bob';\nlet amount = 1234.56;\n\nI18n.use('fr');\nconsole.log(I18n.translate `Hello ${name}, you have ${amount}:c in your bank account.`);\n\nI18n.use('de');\nconsole.log(I18n.translate `Hello ${name}, you have ${amount}:c in your bank account.`);\n\nI18n.use('zh');\nconsole.log(I18n.translate `Hello ${name}, you have ${amount}:c in your bank account.`);\n```\n\n> If a language bundle is called with `I18n.use()` the language *must* exist within the bundle. However, if the translation key does not exist, the default is returned with no localization. In the example above, english would be used.\n\n\n## Module Reference\n\n### I18n.init({initOptions})\n\nInitializes `node-i18n` with the provided options. At least one bundle must be provided.\n\n#### Parameters\n\n- **bundles** : An object containing a property for each supported language, including properties and translation strings.\n- **defaultCurrency**: The default currency to use if none is specified in a bundle.\n\n### I18n.use(lang)\n\nDefines the language bundle used in the next uses of `I18n.translate`. Can be used as many times as necessary, will change the language every time. \n\n> Will fail if `I18n.init()` has not been run.\n\n#### Parameters\n\n- **lang**: The language of the bundle (the key in the bundles object).\n\n### I18n.translate `Template Literal`\n\nExecutes the localization of the template literal following the function. Looks up the template literal as a translation key, returns the processed template literal in its own language if no result is found for the key.\n\n\n## String Building\n\nAlright so now you need to know how to actually build your translation matrix, right? Let's do that. \n\n> In all below example, assume the language bundle is `fr` and that we also have an `en` language bundle where the key and value are identical.\n\nFirst, a simple static string: \n\n```JSON\nstrings: {\n  \"This is a string\": \"Ceci est une chaîne\"\n}\n```\n\nEasy enough, right? Key on the left, translated result on the right. \n\nWell what about variables? You have those, right? In Template Literals, this is called *Expression Interpolation*. So the following expression is valid as a template literal: \n\n```js\nconst myTL = `This string contains a variable ${var}, and can do math: ${2+2}`;\nconsole.log(I18n.translate myTL);\n```\n\nIn `node-i18n`, we can use replace any expression with a numbered placeholder, as such: \n\n```json\nstrings: {\n  \"This string contains a variable {0}, and can do math: {1}\": \"Cette chaîne contient une variable {0} et peut faire des mathématiques: {1}\"\n}\n```\n\nAs you can see, {0} and {1} represent the 2 expressions. Those can actually be used in any order that you want, since they are numbered.  Let's see how: \n\n```json\nstrings: {\n  \"It's a {0} {1}!\": \"C'est un(e) {1} {0}(e)\"\n}\n```\n\nWhich will result in: \n```js\nconst subject = \"car\";\nconst qualifier = \"blue\";\n\nI18n.use(\"en\");\nconsole.log(I18n.translate `It's a ${qualifier} ${subject}!`);\n// It's a blue car!\n\nI18n.use(\"fr\");\nconsole.log(I18n.translate `It's a ${qualifier} ${subject}!`);\n// C'est un(e) car blue(e)!\n```\n\nIs this a bad example? Yes. Absolutely, because the actual values we provide are not translated, so it looks weird. BUT, we can actually go around this. Because a template literal can contain another template literal! Look at this awesomeness: \n\n```json\nstrings: {\n  \"It's a {0} {1}!\": \"C'est un(e) {1} {0}(e)\",\n  \"blue\": \"bleu\",\n  \"car\": \"auto\"\n}\n```\n\n```js\nI18n.use(\"fr\");\nconsole.log(I18n.translate `It's a ${I18n.translate qualifier} ${I18n.translate subject}!`);\n// C'est un(e) auto bleu(e)!\n```\n\nYes I know, it's still imperfect because nothing is done to detect or fix gender in the strings. Nor does this library do proper pluralization.\n\n**One last thing**: The `:c` tag added to any literal defines it as a currency and will appropriately prefix/suffix the key with the appropriate currency tag. Look at the default example at the top of this file for example, where `${currency}:c` is turned into `CA$1,234.56`, `€1,234.56` or `CN¥1,234.5` depending on the language bundle. This uses the native `Number.toLocaleString()` function in JavaScript.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/eslachance/node-i18n.git"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "version": "0.0.1"
}
